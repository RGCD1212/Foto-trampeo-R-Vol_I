---
output:
  pdf_document: default
  html_document: default
---

# Análisis de la actividad: `circular`

### *Mariano Avendaño* {-}

## Introducción

Las cámaras trampa son una herramienta que además de proporcionarnos información sobre la presencia o ausencia de las especies en un determinado sitio, proveen datos sobre los horarios en que los individuos son registrados. Las herramientas estadísticas empleadas para realizar descripción e inferencia sobre la información horaria están basadas en el uso de los análisis estadísticos clásicos, sin embargo tales enfoques podrían generar resultados sesgados o incorrectos. Un ejemplo de lo anterior ocurre al estimar parámetros propios de la estadística descriptiva, tal como la media lo cual se detalla a continuación: se tiene un conjunto de datos (cinco mediciones que corresponden a ángulos): 0°, 10°, 15, 345° y 350°, al estimar la media aritmética nos da un valor de 146°, sin embargo tal valor no se encuentra dentro del rango de nuestros datos. Esto implica que este tipo de datos sean analizados con un enfoque muy diferente al tradicional. 

La estadística circular es una rama de la estadística diseñada para el estudio de datos circulares, es decir, datos que pueden ser representados en un círculo: radianes, ángulos y horas, cada uno con su respectivo equivalente. Ejemplo de datos circulares son la dirección del viento, la dirección de vuelo de un ave con respecto a su nido o los registros horarios en que un individuo es detectado en periodos de 12 o 24 horas, siendo este último tipo de datos los que competen a este capítulo. 

El objetivo del presente capítulo es proveer al usuario de los principales métodos gráficos y estadísticos para analizar la actividad temporal de los individuos obtenidos a través de cámaras trampa. 

## Descripción del paquete

R dispone de diversas librerías para analizar datos circulares siendo las dos más usadas `CircStats` y `circular`, no obstante la primera necesita que los registros horarios estén en radianes para ser analizados y posteriormente ser transformados a horas, lo que probablemente podría dificultar la interpretación de los resultados. Por otro lado, `circular` permite ingresar los registros horarios tal y como son obtenidos, además de realizar algunas ligeras modificaciones, a diferencia de `CircStats` posee un repertorio gráfico más amplio, y obtener gráficas basadas en densidades o gráficos de rosas, entre otros, permitiendo crear gráficos circulares combinados más atractivos para el usuario.

El paquete `circular` [@Agostinelli] se puede bajar directamente desde la librería de CRAN; algunos recursos adicionales se pueden consultar en: <https://cran.r-project.org/web/packages/circular>

## Modificación de los registros y creación de objetos circulares

Para este ejemplo se emplea una base de datos que tiene 100 registros horarios de dos mamíferos: coyote (*Canis latrans*, 72 registros) y conejo (*Sylvilagus floridanus*, 28 registros) obtenidos de cámaras trampa, dicha base fue creada con el paquete `camtrapR` y modificada posteriormente.

Este paquete no reconoce el formato hh:mm:ss por lo que lo cambiaremos a un formato basado en horas decimales (12:15 = 12.25). Este procedimiento puede ser realizado en una hoja de cálculo del programa Excel, dividiendo la columna que contiene los registros de actividad a través de la función "texto en columna" usando ":" como separador. Este proceso nos da tres columnas: horas, minutos y segundos, sin embargo la última columna no se utiliza en el análisis (Figura \@ref(fig:cir1)).

```{r cir1, message = FALSE, warning = FALSE, echo = FALSE, fig.align = "center", fig.height = 7, fig.cap = "Modificación de la columna Tiempo (hh:mm:ss) en columnas independientes Horas y Minutos. La columa Segundos no se utiliza en el análisis."}
par(mar = c(1, 1, 1, 1))
F1 <- imager::load.image("Figura1.png")
plot(F1, axes = F)

```

Posteriormente, la columna de minutos se transforma a valores decimales empleando la fórmula $(x) (0.25) / 15$ [@Zar], donde $x$ corresponde a cada valor de la columna de minutos (Figura \@ref(fig:cir2)). Por último se suma la columna nueva con la columna hora obteniendo así los registros de actividad con el formato deseado.

```{r cir2, message = FALSE, warning = TRUE, echo = FALSE, fig.align = "center", fig.height = 7,  fig.cap = "Transformación de la columna Minutos a Minutos Decimales y porteriormente a Horas Decimales."}
par(mar = c(1,1,1,1))
F2 <- imager::load.image("Figura2.png")
plot(F2, axes = F)

```

Una vez hecho lo anterior se guarda la base de datos con formato ".csv" y se carga en R:

```{r,  message = FALSE, warning = FALSE}
base <- read.csv("BASE_ACTIVIDAD.csv", header = T)
head(base)
```

Como se mencionó anteriormente la base de datos contiene la actividad de dos mamíferos por lo que se procede a escoger los registros de cada uno: 

```{r, echo=TRUE, message=FALSE, warning=FALSE}
coyote <- subset(base, base$Especies == "Canis latrans")
conejo <- subset(base, base$Especies == 
                   "Sylvilagus floridanus")
```

Se carga el paquete como:

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(circular)
```

El paquete `circular` necesita que los datos se encuentre almacenados en objetos circulares por lo que es necesario transformar los registros de actividad a este tipo de objetos, ya que en caso de utilizar alguna de sus funciones con los datos crudos, estos serán transformados usando los parámetros por *default*. Lo anterior podría generar confusiones durante el análisis de los datos e incluso una incorrecta interpretación de los resultados. La función `circular` crea el objeto circular y permite tres tipos de variables: grados, radianes y horas, siendo la última la que se utilizará. Los parámetros más importantes a tener en cuenta al momento de crear el objeto circular es el tipo de unidad en el que serán leídos los datos `units`, en este caso corresponde a horas, otro parámetro es la naturaleza de los datos `template`, es decir, los valores que deben ser tomados para ser graficados: puntos cardinales, radianes u horas. Un tercer parámetro corresponde a la rotación deseada `rotation`, en este análisis corresponde a la dirección de las manecillas del reloj y por último, el punto de inicio `zero`, lo que implica el punto de referencia para graficar los datos siendo las 00:00 horas o pi/2. 

Una vez consciente de estos parámetros se procede a crear el objeto circular para el coyote y el conejo respectivamente:

```{r echo=TRUE, message=FALSE, warning=FALSE}
coy_circular <- circular(coyote$Hora_Decimal, units = 
  "hour", template = "clock24", rotation = "clock",
  zero = pi/2)
head(coy_circular, 5)

con_circular <- circular(conejo$Hora_Decimal, units = 
  "hour", template = "clock24", rotation = "clock", 
  zero = pi/2)
head(con_circular, 5)
```

## Visualización de la actividad 

Una de las principales formas para visualizar los datos es empleando como base los gráficos circulares a los que se les pueden añadir funciones que enriquecen su interpretación. Un primer gráfico se obtiene con las función `plot.circular` o `plot`, ambas grafican la distribución de los registros sobre el círculo, adicionalmente se puede modificar la forma en cómo son presentados los registros, ya sea alrededor de la circunferencia o apilados utilizando el parámetro `stack` (Figura \@ref(fig:cir3)):

```{r cir3, echo=TRUE, fig.align="center", fig.cap= "Ejemplo de gráfico circular donde se muestran los datos del coyote (a) y del conejo (b).", fig.height=7, message=FALSE, warning=FALSE}
par(mfrow = c(1,2), mar = c(1,1,1,1))
plot.circular(coy_circular, shrink = 1.2)
text(x = 1, y = 1, labels = "a")
plot.circular(coy_circular, shrink = 1.2, stack = T)
text(x = 1, y = 1, labels = "b")
```

Una segunda forma para visualizar los datos es a través del diagrama de rosa, este crea histogramas de frecuencia según el número de clases cuyo radio corresponde a la raiz cuadrada de la frecuencia relativa en cada grupo [@Zar; @Agostinelli]. Este tipo de gráfico se obtiene con la función `rose.diag` y el parámetro que define el número de clases es `bins` (Figura \@ref(fig:cir4)a), el parámtero `prop` controla el radio de cada clase, por default es 1 pero en caso de observarse el histograma pequeño, este podría ser sustituido por un valor mayor sin alterar su interpretación.  Si se desa también se pueden visualizar los registros utilizando la función `points.circurlar`  o `points` empleando el objeto circular que los almacena (Figura \@ref(fig:cir4)b). 

Una tercera forma de graficar los datos es usando densidad kernel circular con la función `density.circular`, esta función tiene dos parámetros: el objeto circular `x` y el ancho de banda `bw` cuyo valor debe ser 40 ya que representan mejor los datos [@Pewsey]. Para obtener la densidad de los datos se crea un objeto que tenga dicha información o se puede utilizar la propia función  dentro de la función `plot.circular` (Figura \@ref(fig:cir4)c). Si se desea también se pueden agregar los registros e incluso un diagrama de rosas (Figura \@ref(fig:cir4)d).

```{r cir4, echo=TRUE, fig.align="center", fig.cap="Representación de la actividad del coyote y sus variaciones en gráficos circulares: diagrama de rosa (a)", fig.height=7, message=FALSE, warning=FALSE}
par(mfrow = c(2, 2), mar = c(1, 1, 1, 1))
#Figura 4a
rose.diag(coy_circular, bins = 24, ticks = T, 
          prop = 2, pch = 21, border = "blue", 
          col = "gray", shrink = 1.2) 
text(x = 1, y = 1, labels = "a")
rose.diag(coy_circular, bins = 24, ticks = T, 
          prop = 2, pch = 21, border = "blue", 
          col = "gray", shrink = 1.2) 
#Figura 4b
points.circular(coy_circular, stack = T)  
text(x = 1, y = 1, labels = "b")
plot(density.circular(coy_circular, bw=40), lwd=2, 
     lty=1, main = "", shrink = 1.2) 
#Figura 4c
text(x = 1, y = 1, labels = "c")
plot(density.circular(coy_circular, bw=40), 
     lwd=2, lty=1, main = "", shrink = 1.2) 
#Figura 4d
text(x = 1, y = 1, labels = "d")
points.circular(coy_circular, stack = T) 
rose.diag(coy_circular, bins = 24, ticks = T, 
          prop = 2, pch = 21, border = "blue", 
          col = "gray", add = T) 
```

## Estadística descriptiva

### Medidas de tendencia central

Al igual que en la estadística lineal también se disponen de medidas de tendencia central circular, tal como la media (hora pico o acrofase) [@Batschelet] y la mediana. Para ejemplificar tales medidas se continúa trabajando con los registros del coyote empleando las funciones `mean.circular` y `median.circular`:

```{r, message=FALSE, warning=FALSE}
#Media circular, hora pico o acrofase
mean.circular(coy_circular) 
#Mediana circular
median.circular(coy_circular) 
```

Dado que los resultados para ambas medidas son negativos, media = -1.30 y mediana = -2.43, únicamente se restan a 24 (horas totales del día) de tal forma que la media = 22.7 y la mediana = 21.6. Por último, para obtener su equivalente a minutos (mm) se aplica la fórmula $(x)(15)/(0.25)$, donde $x$ son los decimales, así se concluye que media = 22:42 y mediana = 21:36.

### Medidas de concentración y dispersión

En estadística circular se dispone de una medida de concentración, denominada "longitud del vector promedio", $r$, que en este caso podría ser considerado como la "longitud de la hora promedio". Esta medida indica qué tan dispersos (0) o concentrados (1) están los registros sobre la circunferencia, es decir, si los registros presentan  direccionalidad o se encuentran agrupados en un determinado arco de la circunferencia, más cercano a 1 será su valor. Si el valor es muy cercano a 1 podría entenderse como una preferencia de hora [@Batschelet]. Por otro lado, si los registros se encuentran más dispersos o se distribuyen sobre toda circunferencia, más cercano a 0 será su valor. Para obtener $r$ usamos la función `rho.circular`:

```{r echo=TRUE, message=FALSE, warning=FALSE}
#longitud de la hora promedio
rho.circular(coy_circular)
```

Entre las medidas de dispersión disponibles para datos circulares se encuentra la desviación angular, $s$, y desviación estandar circular, $s_{0}$, ambas son homólogas a la desviación estandar lineal, pero son calculadas de diferentes formas [@Zar]. Para obtenerlas se usan las funciones `angular.deviation` y `sd.circular` o simplemente `sd`:

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Desviación angular
angular.deviation(coy_circular) 
#Desviación estandar circular
sd.circular(coy_circular) 
```

Cualquier valor de $r$ posee sus equivalente para ambas medidas de dispersión, $s$ y $s_{0}$, y pueden ser consutaldos en diferentes fuentes [@Batschelet; @Zar]. Se recomienda que el valor de $r$ se represente a través de gráficos, tal y como se verá más adelante, y que $s$ o $s_{0}$ se reporten en el texto ya que son las medidas que solicitan las editoriales de las revistas.

### Otras medidas

Los intervalos de confianza se obtienen con la función `mle.vonmises. bootstrap.ci`, son tres los parámetros principales: el objeto circular `x`, el valor de significancia `alpha` y el número de remuestreo `reps`:

```{r echo=TRUE, message=FALSE, warning=FALSE, linewidth=55}
mle.vonmises.bootstrap.ci(coy_circular, 
                          alpha = 0.05, reps = 1000)
```

Cabe mencionar que los valores de la media, mediana, la longitud del vector promedio e incluso los intervalos de confianza pueden ser representados visualmente (Figura \@ref(fig:cir5)) utilizando la función `arrows.circular` :

```{r cir5, echo=TRUE, fig.align="center", out.width="75%", message=FALSE, warning=FALSE, fig.cap="Ejemplo de gráfico circular representando con flechas de color diferentes estadísticos."}
plot.circular(coy_circular, shrink = 1.2, stack = T)
#Graficando la media y longitud de la hora promedio
arrows.circular(mean.circular(coy_circular),
            rho.circular(coy_circular), x0 = 0, 
            col = "blue", lwd = 1.9, lty = 8) 
#Graficando la mediana
arrows.circular(median.circular(coy_circular), 
                x0 = 0, col = "red", 
                lwd = 1.9, lty = 6) 
#Obtención de los intervalos de confianza
coy_ci <- mle.vonmises.bootstrap.ci(coy_circular, 
                alpha = 0.05, reps = 1000)
#Graficando los intervalos de confianza
arrows.circular(coy_ci$mu.ci, x0 = 0, col = "black", 
                lwd = 1.9, lty = 6)
```

## Estadística inferencial

### Uniformidad *vs* direccionalidad

En estadística circular existen diferentes distribuciones circulares siendo las dos más frecuentes la *uniforme* y *von Mises*. La distribución *uniforme* establece que los datos se distribuyen con la misma probabilidad en toda la circunferencia, mientras que la distribución *von Mises* establece que determinado arco de la circunferencia posee mayor probabilidad para ser registrado, siendo así una distribución unimodal como su principal característica (Figura \@ref(fig:cir6)).

```{r cir6, echo=TRUE, fig.align='center', fig.height=7, fig.width=10, message=FALSE, warning=FALSE, fig.cap="Ejemplo gráfico de las funciones uniforme y la Von Mises."}
par(mfrow = c (1, 2))
unif <- rcircularuniform(100)
plot(unif, template = "clock24")
text(x = 1, y = 1, labels = "a")
von <- rvonmises(100, circular(1), 10)
plot(von, template = "clock24")
text(x = 1, y = 1, labels = "b")
```

Para determinar si los registros de actividad poseen una distribución uniforme o von Mises lo primero debería ser un análisis visual de los datos además de revisar el valor de $r$, sin embargo en caso de que $r$ sea cercano a 0 no indica que no exista unidireccionalidad [@Zar]. Ante esta situación existen una serie de pruebas estadísticas circulares diseñadas para determinar si existe uniformidad, unimodalidad o multimodalidad. El paquete `circular` dispone de las siguientes pruebas: 

* *Rayleigh test*
* *Rao´s spacing test*
* *Kuiper test*
* *Watson test*

Todos ellas tienen como hipótesis nula $H_{0}:$ la distribución de los datos es al azar y por lo tanto siguen una distribución uniforme, y como hipótesis alternativa $H_{A}:$ los datos no están distribuidos al azar y muestran direccionalidad. Cada prueba posee supuestos muy similares entre sí, principalmente que los datos no se encuentren agrupados y en caso de estarlos, los intervalos no sean mayores a 5° [@Batschelet], sin embargo hay algo muy importante a resaltar: *Rayleigh test* únicamente es aplicable para datos unimodales o  unidireccionales, es decir, datos agrupados en determinado arco de la circunferencia, sin importar que algunos pocos datos estén en otras partes. 

Por otro lado, a diferencia de la anterior las tres pruebas restantes pueden tratar con datos unimodales, bimodales o multimodales, es decir, datos agrupados en más de una dirección [@Batschelet; @Zar]. Por lo tanto, es conveniente realizar un análisis exploratorio de los datos empleando gráficos circulares o gráficos de densidad, y basado en ello decidir qué ánalisis es el más adecuado. Esto es de gran importancia debido a que en especies catemerales (con actividad diurna, noctura y crespucular) podría ser conveniente aplicar cualquiera de los últimas tres pruebas, mientras que en especies con actividad marcada (nocturna o diurna) la primera prueba sería lo ideal.

Cada una de las pruebas es realizada con las siguiente funciones:

```{r echo=TRUE, message=FALSE, warning=FALSE}
options(scipen = 999)
#Rayleigh test
rayleigh.test(coy_circular) 
#Rao´s spacing test
rao.spacing.test(coy_circular, alpha = 0.05) 
#Kuiper test
kuiper.test(coy_circular, alpha = 0.05) 
#Watson test
watson.test(coy_circular, alpha = 0.05) 
```

### Comparando los periodos de actividad

Entre las pruebas para comparar la actividad temporal ya sea entre sexos, temporadas o especies, el paquete `circular` dispone de tres:

* *Watson-William test*
* *Watson test para dos muestras*
* *Watson-Wheeler test o Mardia-Wheeler-Watson test*

*Watson-William test* tiene como hipótesis nula $H_{0}:$ el ángulo (hora) promedio de ambas muestras es el mismo y como hipótesis alternativa $H_{A}:$ el ángulo (hora) promedio de ambas muestras es diferente [@Zar]. Este es homólogo a las pruebas paramétricas ya que establece que ambas muestras poseen una distribución *von Mises*, además deben tener el mismo parámetro de concentración *kappa* consultar a Batschelet [-@Batschelet] y Zar [-@Zar], por lo que en caso de no cumplirse tales supuestos los resultados podrían estar sesgados, no obstante algunos autores lo consideran muy robusto aún cuando no se cumple alguno de estos supuestos [@Zar]. Esta prueba también puede ser aplicada para más de dos muestras. La función empleada para realizarla es `watson.williams.test`, cabe mencionar que las muestras deben estar almacenadas en una lista `list`, para ejemplificarla se compara la actividad del coyote y del conejo:

```{r echo=TRUE, message=FALSE, warning=FALSE, linewidth=55}
#Watson-Williams test
watson.williams.test(list(coy_circular, con_circular), 
                     alpha = 0.05)
```

La ventaja de esta función es que en caso de violarse algún supuesto, en este caso el valor del parámetro de concentración *kappa* no es el mismo en ambas muestras (segundo supuesto), nos muestra un mensaje advitiérdonos que este análisis puede no ser el adecuado para los datos.

Dado lo anterior se tienen otras pruebas como Watson test para dos muestras y Watson-wheeler, ambas consideradas como pruebas no paramétricas, ya que no necesitan que las muestras posean la misma distribución ni tener el mismo parámetro de concentración. Sin embargo *Watson-Wheeler* necesita que no existan registros idénticos dentro de cada una de las muestras y entre muestras (Bachelester, 1981), ya que en caso contrario mostrará un mensaje con el número de registros idénticos, sugiriendo que sean eliminados al azar y se corra el test cada vez que uno es eliminado. Ambas pruebas tienen como hipótesis nula $H_{0}:$ las poblaciones de las dos muestras son idénticas y como hipótesis alternátiva $H_{A}:$ las poblaciones de las dos muestras son diferentes [@Zar]. Las funciónes empleadas para realizarlas son `watson.two.test` y `watson.wheeler.test`:

```{r echo=TRUE, message=FALSE, warning=FALSE, linewidth=55}
#Watson test para dos muestras
watson.two.test(coy_circular, con_circular, 
                alpha = 0.05) 
#Watson-Wheeler test
watson.wheeler.test(list(coy_circular, con_circular), 
                    alpha = 0.05) 
```

Al realizar la prueba *Watson-Wheeler* se muestra una leyenda indicando que existen 8 registros repetidos y que deben ser eliminados. En este caso se proceden a eliminar todos de una sola vez:

```{r echo=TRUE, message=FALSE, warning=FALSE, linewidth=55}
#Eliminación de duplicados desde la base original
base_sd <- base[!duplicated(base$Hora_Decimal), ]
```

```{r, echo = TRUE, message = FALSE, warning = FALSE, linewidth=55}
coyote_sd <- subset(base_sd, 
              base$Especies == "Canis latrans")
conejo_sd <- subset(base_sd, 
              base$Especies == "Sylvilagus floridanus")
coy_circular_sd <- circular(coyote_sd$Hora_Decimal, 
              units = "hour", template = "clock24",
              rotation = "clock", zero = pi/2)
con_circular_sd <- circular(conejo_sd$Hora_Decimal, 
              units = "hour", template = "clock24",
              rotation = "clock", zero = pi/2)
```

Los dos nuevos vectores son: `coy_circular_sd` y `con_circular_sd (se crearon siguiendo los pasos descritos anteriormente) y se proceden a analizar nuevamente:

```{r echo=TRUE, message=FALSE, warning=FALSE, linewidth=55}
watson.wheeler.test(list(coy_circular_sd, 
                  con_circular_sd), alpha = 0.05)
```

Así se observa que a pesar de quitar los registros duplicados se sigue aceptando la hipótesis nula, ambas muestras son iguales.

## Intervalos y coeficiente de traslape

El paquete `circular` dispone de dos funciones que también permiten obtener información sobre la actividad de los individuos: `modal.region` y `totalvariation.circular`, ambas desarrolladas por Oliveira-Santos et al. [-@Oliveira], basadas en el análisis de densidad kernel empleando un enfoque muy similar a su uso en la estimación del ámbito hogareño. 

La función `modal.region` determina dos tipos de actividad: el *Intervalo de actividad* que estima el 95% del tiempo en que el individuo se mantiene activo y el *Intervalo de actividad núcleo*, es decir, determina el intervalo en el que se concentró el 50% de toda su actividad. Ambos intervalos permiten identificar picos de mayor actividad. La función necesita de tres argumentos principales: el objeto circular `x`, el intervalo de actividad que queremos determinar utilizando un rango de 0 a 1 (95% = 0.95 y 50% = 0.50) `q` y el parámetro de suavizado que de acuerdo con las recomendaciones de los autores debe ser de 5 `bw` [@Oliveira].

Para calcular el intervalo de actividad (95%) se emplea:

```{r echo=TRUE, message=FALSE, warning=FALSE}
coyote95 <- modal.region(coy_circular, q = 0.95, bw = 5)
coyote95$zeros
```

Para el intervalo de actividad núcleo (50%):

```{r echo=TRUE, message=FALSE, warning=FALSE}
coyote50 <- modal.region(coy_circular, q = 0.50, bw = 5)
coyote50$zeros
```

El intervalo horario se almacena en el objeto *zeros* del vector asignado a la función. Con respecto al *Intervalo de actividad* el periodo es representado por la segunda columna de la primera fila y el límite y la primera columa de la segunda fila, mientras que el *Intervalo de actividad núcleo* únicamente es representado por una fila con sus respectivas columans. Los número negativos deben ser restados a 24 y ser leídos de derecha a izquierda. De tal forma que el *Intervalo de actividad (95%)* abarcó de las 17:48 - 12:57 horas y el *Intervalo de actividad núcleo (50%)* de las 18:12 - 01:24.

Si se quieren visualizar dichos intervalos únicamente graficamos los vectores que almacenan el *Intervalo de actividad* (coyote95) y el *Intervalo de actividad núcleo* (coyote50) empleando la función `plot`. Ambos rangos de actividad se encuentran por encima de la línea punteada (Figura \@ref(fig:cir7)).

```{r cir7, echo=TRUE, fig.align='center', message=FALSE, warning=FALSE, out.width="85%"}
par(mfrow = c(1,2), mar = c(4,4,2,1))
plot(coyote95, main = "Intervalo de actividad (95%)", 
     ylab = "Densidad", xlab = "Horas", cex.main = 0.8)
plot(coyote50, main = "Intervalo de actividad 
     núcleo (50%)", 
     ylab = "Densidad", xlab = "Horas", cex.main = 0.8)
```

La función `totalvariation.circular` cuantifica el coeficiente de traslape (OVL) de la actividad de los individuos ya sea entre temporadas, entre sexo o entre  especies, posee un intervalo de 0 (los dos tipos de actividad no se intersectan) a 1 (completa intersección). OVL es utilizado en la función `overlapEst` del paquete `overlap` [@Oliveira; @Meredith]. Adicionalmente OVL es complementado con una medida de disimilitud conocida como "distancia de variación total (TV)", que también posee un intervalo de 0 (mismo tipo de actividad, p. ej. diurno vs diurno) a 1 (diferente tipo de actividad, p. ej. diurno vs nocturno), la suma de OVL y TV corresponde a 1 [@Oliveira]. 

Una característica importante de esta función es que permite cuantificar OVL y TV en el *Intervalo de actividad (95%)* así como en el *Intervalo de actividad núcleo (50%)* y de esta forma se puede saber su variación del traslape y disimilitud. La función `totalvariation.circular` además de utilizar un segundo objeto circular, el cual representa la actividad en una distinta temporada, distinto sexo o especie, utiliza los mismos argumentos que `modal.region`. Los valores de OVL y TV se encuentran dentro del vector asignado a la función con los mismo nombres.

```{r echo=TRUE, message=FALSE, warning=FALSE}
coy_cone95 <- totalvariation.circular(coy_circular, 
                        con_circular, q = 0.95, bw = 5)
coy_cone50 <- totalvariation.circular(coy_circular, 
                        con_circular, q = 0.50, bw = 5)
```

Los resultados de este análisis se pueden presentar en el Cuadro \@ref(tab:cir8).

```{r cir8, message = FALSE, warning = FALSE, echo = FALSE}
knitr::kable(read.csv("TRASLAPE.csv"), align = "c", col.names = c("Parámetro", "Coyote - Conejo (95%)", "Coyote - Conejo (50%)"), format = "pandoc", caption = "Traslape de actividad (OVL) y variación total (TV) en el intervalo de actividad (95%) e intervalo de actividad núcleo (50%) entre el coyote y el conejo.")
```

## Sumario

En este capítulo se describe paso a paso el empleo general del paquete `circular`. Este proceso es de mucha utilidad para datos ecológicos temporales y emplea el enfoque de estadística circular. Considerando que la mayoría de los modelos de cámaras-trampa captura la hora a la que es fotografiado el animal, estos datos pueden ser analizados con este paquete.